Why Use Virtual Environments?

Problem:
If you install packages globally, all your projects share the same libraries 
causing version conflicts.

Example:
Project A needs Flask==2.0
Project B needs Flask==3.0

Global installation breaks one of them.

Solution:

A virtual environment (venv) is an isolated workspace that keeps packages separate for each project.
Each environment has:
Its own Python interpreter
Its own pip
Its own installed libraries




Creating and Activating a Virtual Environment
Step 1 — Create Environment
python -m venv venv

Step 2 — Activate Environment

| System                   | Command                          |
| ------------------------ | -------------------------------- |
| **Windows (cmd)**        | `venv\Scripts\activate`          |
| **Windows (PowerShell)** | `.\\venv\\Scripts\\Activate.ps1` |
| **macOS / Linux**        | `source venv/bin/activate`       |


Step 3 — Install Packages Inside venv

pip install  django
pip install requests


step 3 :Deactivate Environment

Exporting & Recreating Environments
When working with teammates or deploying a project, you need to share which
packages your app requires.

Step 1 — Export Installed Packages
pip freeze > requirements.txt

Step 2 — Recreate Environment on Another Machine
pip install -r requirements.txt

Checking What’s Installed
pip list